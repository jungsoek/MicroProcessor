# 10. ë§ˆì´í¬ë¡œí”„ë¡œì„¸ì„œ ì„¤ê³„ ë° ì‹œë®¬ë ˆì´ì…˜

## 10.1 ê¸°ë³¸ CPU ì„¤ê³„ (8ë¹„íŠ¸/16ë¹„íŠ¸)

### ğŸ§  ê¸°ë³¸ CPUë€?

**ê¸°ë³¸ CPU ì„¤ê³„**ëŠ” **ìµœì†Œí•œì˜ í•˜ë“œì›¨ì–´ ìì›ìœ¼ë¡œë„ ëª…ë ¹ì–´ ì‹¤í–‰ì´ ê°€ëŠ¥í•˜ë„ë¡ êµ¬ì„±ëœ ì¤‘ì•™ì²˜ë¦¬ì¥ì¹˜**ì•¼.
 ëŒ€ê°œ ë‹¤ìŒ ìš”ì†Œë“¤ì„ í¬í•¨í•˜ê³ :

| êµ¬ì„± ìš”ì†Œ                  | ê¸°ëŠ¥                  |
| -------------------------- | --------------------- |
| **ë ˆì§€ìŠ¤í„°(Register)**     | ì„ì‹œ ë°ì´í„° ì €ì¥      |
| **ALU**                    | ì‚°ìˆ /ë…¼ë¦¬ ì—°ì‚°        |
| **Program Counter(PC)**    | ëª…ë ¹ì–´ ìœ„ì¹˜ ì¶”ì       |
| **ë©”ëª¨ë¦¬ ì¸í„°í˜ì´ìŠ¤**      | RAM/ROM ì ‘ê·¼          |
| **ì œì–´ì¥ì¹˜(Control Unit)** | ì „ì²´ ë™ì‘ ì œì–´        |
| **ë²„ìŠ¤ êµ¬ì¡°**              | ë°ì´í„°/ì£¼ì†Œ ì „ë‹¬ ê²½ë¡œ |

### ğŸ“ 8ë¹„íŠ¸ vs 16ë¹„íŠ¸ CPUë€?

| í•­ëª©              | 8ë¹„íŠ¸ CPU                   | 16ë¹„íŠ¸ CPU          |
| ----------------- | --------------------------- | ------------------- |
| **ë°ì´í„° í­**     | í•œ ë²ˆì— 8ë¹„íŠ¸ ì²˜ë¦¬          | 16ë¹„íŠ¸ ì²˜ë¦¬         |
| **ë ˆì§€ìŠ¤í„° í¬ê¸°** | 8ë¹„íŠ¸                       | 16ë¹„íŠ¸              |
| **ì£¼ì†Œ ë²„ìŠ¤ í­**  | ë³´í†µ 16ë¹„íŠ¸ (64KB ì£¼ì†Œê³µê°„) | ìµœëŒ€ 64KB ì´ìƒ      |
| **ì—°ì‚° ëŠ¥ë ¥**     | ë‹¨ìˆœ, ì €ì†                  | ë” ë¹ ë¥´ê³  ì •ë°€      |
| **ëŒ€í‘œ**          | 6502, Z80, 8051             | 8086, MSP430, HCS12 |

### ğŸ§± ê¸°ë³¸ CPU êµ¬ì„± ë¸”ë¡ ë‹¤ì´ì–´ê·¸ë¨

```
     +--------------+
     | Program      | â† ROM
     | Counter (PC) |
     +------+-------+
            |
            v
     +--------------+
     | Instruction  | â† ëª…ë ¹ì–´ ë©”ëª¨ë¦¬
     | Register (IR)|
     +------+-------+
            |
            v
     +--------------+       +---------------+
     | Control Unit | ----> |   Control     |
     +--------------+       |   Signals     |
            |                       |
            v                       v
     +------+--------+      +------------------+
     | ALU           | <--> | Register File    |
     +---------------+      +------------------+
            |
            v
     +--------------+
     | Data Memory  | â† RAM
     +--------------+
```

### ğŸ” ëª…ë ¹ì–´ ì‹¤í–‰ íë¦„ (Fetch â†’ Decode â†’ Execute)

1. **Fetch**: PCê°€ ê°€ë¦¬í‚¤ëŠ” ë©”ëª¨ë¦¬ì—ì„œ ëª…ë ¹ì–´ ì½ìŒ
2. **Decode**: ëª…ë ¹ì–´ë¥¼ í•´ì„í•˜ê³  ì œì–´ì‹ í˜¸ ìƒì„±
3. **Execute**: ALUê°€ ì—°ì‚° or ë©”ëª¨ë¦¬ ì ‘ê·¼
4. **Write-back**: ê²°ê³¼ë¥¼ ë ˆì§€ìŠ¤í„°ë‚˜ ë©”ëª¨ë¦¬ì— ì €ì¥
5. **PC ê°±ì‹ **: ë‹¤ìŒ ëª…ë ¹ì–´ë¡œ ì´ë™

### ğŸ”¢ ëª…ë ¹ì–´ ì§‘í•© ì˜ˆ (8ë¹„íŠ¸ ê¸°ì¤€)

| ëª…ë ¹         | ì„¤ëª…        | í¬ë§·                  |
| ------------ | ----------- | --------------------- |
| `LD Rn, imm` | ì¦‰ì‹œê°’ ë¡œë“œ | `0001 rrrr dddd dddd` |
| `ADD R1, R2` | ë§ì…ˆ        | `0010 rrrr ssss xxxx` |
| `SUB R1, R2` | ëº„ì…ˆ        | `0011 rrrr ssss xxxx` |
| `JMP addr`   | ë¬´ì¡°ê±´ ì í”„ | `0100 aaaa aaaa aaaa` |
| `BZ addr`    | 0ì´ë©´ ì í”„  | `0101 aaaa aaaa aaaa` |
| `OUT R1`     | í¬íŠ¸ë¡œ ì¶œë ¥ | `0110 rrrr xxxx xxxx` |

### ğŸ§® ALU ê¸°ë³¸ êµ¬ì„±

- ì…ë ¥: A, B (ë ˆì§€ìŠ¤í„° or ë©”ëª¨ë¦¬ ë°ì´í„°)
- ì¶œë ¥: ê²°ê³¼ + ìƒíƒœ í”Œë˜ê·¸(Z, N, C, V)
- ì—°ì‚°: `ADD`, `SUB`, `AND`, `OR`, `XOR`, `NOT`, `SHL`, `SHR`

### ğŸ“¦ ë ˆì§€ìŠ¤í„° êµ¬ì„± ì˜ˆ

| ì´ë¦„         | ì„¤ëª…                                   |
| ------------ | -------------------------------------- |
| **R0~R7**    | ë²”ìš© ë ˆì§€ìŠ¤í„° (8ê°œ, 8ë¹„íŠ¸ ë˜ëŠ” 16ë¹„íŠ¸) |
| **ACC**      | ëˆ„ì‚°ê¸° (ALU ê¸°ë³¸ ì—°ì‚°ì— ì‚¬ìš©)          |
| **PC**       | í”„ë¡œê·¸ë¨ ì¹´ìš´í„°                        |
| **IR**       | ëª…ë ¹ì–´ ë ˆì§€ìŠ¤í„°                        |
| **SP**       | ìŠ¤íƒ í¬ì¸í„°                            |
| **SR/FLAGS** | ìƒíƒœ ë ˆì§€ìŠ¤í„° (Z, C, N, V í”Œë˜ê·¸)      |

### ğŸ”Œ ë°ì´í„° ë²„ìŠ¤ì™€ ì œì–´ ì‹ í˜¸

| ì‹ í˜¸            | ì„¤ëª…                                         |
| --------------- | -------------------------------------------- |
| **Data Bus**    | ALU â†” ë ˆì§€ìŠ¤í„° â†” ë©”ëª¨ë¦¬ ê°„ ë°ì´í„° ì „ë‹¬       |
| **Address Bus** | PC ë˜ëŠ” ë§ˆì´í¬ë¡œì œì–´ê¸°ì—ì„œ RAM/ROM ì£¼ì†Œ ì§€ì • |
| **Read/Write**  | ë©”ëª¨ë¦¬ ì ‘ê·¼ ì‹œ ë°©í–¥ ì œì–´                     |
| **ALU_OP**      | ì—°ì‚° ì¢…ë¥˜ ì„ íƒ                               |
| **LOAD/STORE**  | ë ˆì§€ìŠ¤í„° â†” ë©”ëª¨ë¦¬ ì „ì†¡ ì‹œ ì‚¬ìš©               |

### ğŸ§ª ì„¤ê³„ ì˜ˆì‹œ: 8ë¹„íŠ¸ RISC CPU

- **ë ˆì§€ìŠ¤í„° íŒŒì¼**: R0~R7 (8ê°œ, 8ë¹„íŠ¸)
- **ALU**: 1 ì‚¬ì´í´ ë™ì‘
- **ROM**: ëª…ë ¹ì–´ ì €ì¥ (256ë°”ì´íŠ¸)
- **RAM**: ë°ì´í„° ì €ì¥ìš© (128ë°”ì´íŠ¸)
- **PC**: 8ë¹„íŠ¸ (256ê°œ ëª…ë ¹ì–´ ê³µê°„)
- **ì œì–´ê¸°**: FSM ê¸°ë°˜ í•˜ë“œì™€ì´ì–´ë“œ ë°©ì‹ or ë§ˆì´í¬ë¡œì½”ë“œ ê¸°ë°˜

### ğŸ› ï¸ ì„¤ê³„ ì‹œ ê³ ë ¤ì‚¬í•­

| í•­ëª©                    | ì„¤ëª…                                      |
| ----------------------- | ----------------------------------------- |
| **ëª…ë ¹ì–´ í­ ê²°ì •**      | ê³ ì •í˜•(ì˜ˆ: 16ë¹„íŠ¸) or ê°€ë³€í˜•              |
| **íŒŒì´í”„ë¼ì¸ ì—¬ë¶€**     | ë‹¨ìˆœ êµ¬ì¡°ëŠ” ì¼ë°˜ì ìœ¼ë¡œ ë¹„íŒŒì´í”„ë¼ì¸       |
| **ì œì–´ ë°©ì‹**           | FSM í•˜ë“œì™€ì´ì–´ë“œ / ë§ˆì´í¬ë¡œì½”ë“œ ì„ íƒ ê°€ëŠ¥ |
| **í™•ì¥ì„±**              | ì¸í„°ëŸ½íŠ¸, I/O í¬íŠ¸, ìŠ¤íƒ êµ¬ì¡° í•„ìš” ì—¬ë¶€   |
| **ë””ë²„ê¹…ìš© ì¸í„°í˜ì´ìŠ¤** | PC, IR ì¶œë ¥ ê°€ëŠ¥í•˜ê²Œ ì„¤ê³„                 |

### ğŸ“Œ ìš”ì•½ ì •ë¦¬

| í•­ëª©            | 8ë¹„íŠ¸ CPU        | 16ë¹„íŠ¸ CPU             |
| --------------- | ---------------- | ---------------------- |
| **ë°ì´í„° í­**   | 1ë°”ì´íŠ¸          | 2ë°”ì´íŠ¸                |
| **ëª…ë ¹ì–´ í¬ê¸°** | ë³´í†µ 8~16ë¹„íŠ¸    | ë³´í†µ 16~32ë¹„íŠ¸         |
| **ë ˆì§€ìŠ¤í„°**    | 8ë¹„íŠ¸ í­, ì†Œí˜•   | 16ë¹„íŠ¸ í­, í™•ì¥        |
| **ALU êµ¬ì„±**    | ê¸°ë³¸ ì—°ì‚°        | ì •ë°€ ì—°ì‚°ê¹Œì§€ í¬í•¨     |
| **ì„¤ê³„ ë‚œì´ë„** | ë‚®ìŒ             | ì¤‘ê°„ ìˆ˜ì¤€              |
| **ì‘ìš©**        | êµìœ¡ìš©, ì„ë² ë””ë“œ | ê³ ê¸‰ ì œì–´ê¸°, RTOS ëŒ€ìƒ |

## 10.2 Verilog/VHDLì„ ì´ìš©í•œ í”„ë¡œì„¸ì„œ êµ¬í˜„

### ğŸ§  ì™œ HDL(Hardware Description Language)ë¡œ CPUë¥¼ êµ¬í˜„í•˜ëŠ”ê°€?

HDL(Verilog ë˜ëŠ” VHDL)ì€ **í•˜ë“œì›¨ì–´ ë™ì‘ì„ ë…¼ë¦¬ì ìœ¼ë¡œ í‘œí˜„**í•˜ëŠ” ì–¸ì–´ë¡œ,
 ë””ì§€í„¸ íšŒë¡œ(íŠ¹íˆ CPU)ë¥¼ **ì„¤ê³„, ì‹œë®¬ë ˆì´ì…˜, í•©ì„±(Synthesis)**í•  ìˆ˜ ìˆê²Œ í•´ì¤˜.

> ëª…ë ¹ì–´ í•´ì„, ALU ì—°ì‚°, ë©”ëª¨ë¦¬ ì ‘ê·¼, ì œì–´ ì‹ í˜¸ ë°œìƒ ë“±ì„
>  **RTL(Register Transfer Level)**ë¡œ ê¸°ìˆ í•˜ì—¬ ì‹¤ì œ FPGAë‚˜ ASIC êµ¬í˜„ì´ ê°€ëŠ¥í•´ì§.

### ğŸ“¦ ê¸°ë³¸ CPU ì„¤ê³„ êµ¬ì„± (ëª¨ë“ˆ ë‹¨ìœ„)

```
Top-Level CPU
 â”œâ”€â”€ Program Counter (PC)
 â”œâ”€â”€ Instruction Memory (ROM)
 â”œâ”€â”€ Instruction Decoder
 â”œâ”€â”€ Register File
 â”œâ”€â”€ ALU
 â”œâ”€â”€ Data Memory (RAM)
 â””â”€â”€ Control Unit
```

### ğŸ”§ Verilog ëª¨ë“ˆ ì˜ˆì œ êµ¬ì¡°

```
module cpu (
    input wire clk,
    input wire reset
);
    // ë‚´ë¶€ ì‹ í˜¸ ì„ ì–¸
    wire [7:0] instruction;
    wire [7:0] reg_a, reg_b, alu_out;
    wire [2:0] alu_op;

    // ì¸ìŠ¤í„´ìŠ¤ ì—°ê²°
    program_counter pc(...);
    instruction_memory imem(...);
    decoder decode(...);
    register_file rf(...);
    alu my_alu(...);
    control_unit cu(...);
endmodule
```

### ğŸ§® ì£¼ìš” ëª¨ë“ˆë³„ Verilog êµ¬í˜„ ì˜ˆì‹œ

#### âœ… 1. ALU ì˜ˆì œ (8ë¹„íŠ¸)

```
module alu (
    input [7:0] a, b,
    input [2:0] op,
    output reg [7:0] result,
    output zero
);
    always @(*) begin
        case (op)
            3'b000: result = a + b;
            3'b001: result = a - b;
            3'b010: result = a & b;
            3'b011: result = a | b;
            3'b100: result = ~a;
            default: result = 8'b0;
        endcase
    end

    assign zero = (result == 8'b0);
endmodule
```

#### âœ… 2. Register File (8ê°œ ë ˆì§€ìŠ¤í„°, 8ë¹„íŠ¸)

```
module register_file (
    input clk,
    input [2:0] read_addr1, read_addr2, write_addr,
    input write_en,
    input [7:0] write_data,
    output [7:0] read_data1, read_data2
);
    reg [7:0] regs [0:7];

    always @(posedge clk)
        if (write_en)
            regs[write_addr] <= write_data;

    assign read_data1 = regs[read_addr1];
    assign read_data2 = regs[read_addr2];
endmodule
```

#### âœ… 3. Program Counter

```
module program_counter (
    input clk,
    input reset,
    input [7:0] next_pc,
    output reg [7:0] pc
);
    always @(posedge clk or posedge reset)
        if (reset) pc <= 8'b0;
        else pc <= next_pc;
endmodule
```

#### âœ… 4. ê°„ë‹¨í•œ Control Unit (FSM ê¸°ë°˜)

```
module control_unit (
    input [7:0] opcode,
    output reg alu_src,
    output reg reg_write,
    output reg mem_read,
    output reg mem_write,
    output reg [2:0] alu_op
);
    always @(*) begin
        case (opcode[7:4])
            4'b0001: begin // ADD
                alu_op = 3'b000;
                alu_src = 0;
                reg_write = 1;
            end
            4'b0010: begin // SUB
                alu_op = 3'b001;
                alu_src = 0;
                reg_write = 1;
            end
            // ...
            default: begin
                alu_op = 3'b000;
                reg_write = 0;
            end
        endcase
    end
endmodule
```

### ğŸ§ª í…ŒìŠ¤íŠ¸ë²¤ì¹˜ ì˜ˆì‹œ

```
module cpu_tb;
    reg clk = 0;
    reg reset = 1;

    cpu uut (
        .clk(clk),
        .reset(reset)
    );

    always #5 clk = ~clk;

    initial begin
        #10 reset = 0;
        #100 $stop;
    end
endmodule
```

### ğŸ§° ì‹œë®¬ë ˆì´ì…˜ & í•©ì„± íë¦„

| ë‹¨ê³„            | ë„êµ¬ ì˜ˆì‹œ                                   |
| --------------- | ------------------------------------------- |
| ì‘ì„±            | Verilog/VHDL í…ìŠ¤íŠ¸ ì‘ì„±                    |
| ì‹œë®¬ë ˆì´ì…˜      | ModelSim, Icarus Verilog, Vivado Simulation |
| ê²€ì¦            | Testbench í†µí•´ ê¸°ëŠ¥ í™•ì¸                    |
| í•©ì„±(Synthesis) | Vivado, Quartus, Design Compiler ë“±         |
| íƒ€ì´ë° ë¶„ì„     | STA ë„êµ¬ë¥¼ í†µí•´ ë™ì‘ ì†ë„ ê²€ì¦              |
| ë°°ì¹˜ ë°°ì„        | FPGA/ASIC ë¬¼ë¦¬ êµ¬í˜„ ë‹¨ê³„                    |
| ë‹¤ìš´ë¡œë“œ        | FPGAì— Bitstream ë‹¤ìš´ë¡œë“œ                   |

### ğŸ“Œ ìš”ì•½ ì •ë¦¬

| í•­ëª©                | ì„¤ëª…                                      |
| ------------------- | ----------------------------------------- |
| **HDL ì‚¬ìš© ëª©ì **   | CPU í•˜ë“œì›¨ì–´ ë…¼ë¦¬ë¥¼ ë””ì§€í„¸ ë…¼ë¦¬ë¡œ ê¸°ìˆ     |
| **ëª¨ë“ˆ êµ¬ì„±**       | PC, ALU, RegFile, RAM, ì œì–´ê¸° ë“±ìœ¼ë¡œ ë¶„ë¦¬ |
| **RTL ì„¤ê³„**        | Clock, ìƒíƒœ, ì œì–´ ì‹ í˜¸ íë¦„ ì¤‘ì‹¬          |
| **ì‹œë®¬ë ˆì´ì…˜ í•„ìˆ˜** | ê²€ì¦ ì—†ì´ëŠ” íšŒë¡œ ë™ì‘ ë³´ì¥ ì–´ë ¤ì›€         |
| **í•©ì„± ì¤€ë¹„**       | íƒ€ì´ë°, ìì› ì‚¬ìš©ëŸ‰, ìµœì í™” ê³ ë ¤ í•„ìš”     |

## 10.3 FSM ê¸°ë°˜ ì œì–´ê¸° ì„¤ê³„

> ëª…ë ¹ì–´ ì‹¤í–‰ íë¦„ì„ ìƒíƒœ(state)ë¡œ ì •ì˜í•˜ì—¬ ì œì–´í•˜ì

### ğŸ§  FSMì´ë€?

**FSM(Finite State Machine)**ì€ ì‹œìŠ¤í…œì˜ ë™ì‘ì„
 **ìœ í•œí•œ ìƒíƒœë“¤ì˜ ì§‘í•©ê³¼ ìƒíƒœ ì „ì´ ê·œì¹™ìœ¼ë¡œ ëª¨ë¸ë§**í•œ ì œì–´ ë°©ì‹ì´ì•¼.

> í•˜ë‚˜ì˜ CPU ëª…ë ¹ì–´ ì‹¤í–‰ì„ **ì—¬ëŸ¬ ìƒíƒœ(State)**ë¡œ ë‚˜ëˆ„ê³ 
>  ê°ê°ì˜ ìƒíƒœì—ì„œ **ì–´ë–¤ ì œì–´ ì‹ í˜¸ë¥¼ ë‚¼ì§€ ê²°ì •**í•˜ëŠ” ë°©ì‹ìœ¼ë¡œ ì œì–´ê¸°ë¥¼ êµ¬ì„±í•¨.

### ğŸ”„ FSM ì œì–´ê¸°ì˜ íŠ¹ì§•

| í•­ëª©                           | ì„¤ëª…                                           |
| ------------------------------ | ---------------------------------------------- |
| **ì •í˜•ì **                     | ìƒíƒœ ì „ì´í‘œ ë˜ëŠ” ìƒíƒœë„ì— ë”°ë¼ ì œì–´            |
| **ë‹¨ê³„ë³„ ì‹¤í–‰**                | ëª…ë ¹ì–´ í•˜ë‚˜ë¥¼ ì—¬ëŸ¬ í´ëŸ­ì— ê±¸ì³ ì²˜ë¦¬            |
| **ëª…í™•í•œ íƒ€ì´ë° ì œì–´**         | ê° ìƒíƒœë§ˆë‹¤ ê³ ìœ í•œ ë™ì‘ ìˆ˜í–‰ ê°€ëŠ¥              |
| **í•˜ë“œì™€ì´ì–´ë“œ ì œì–´ê¸°ì™€ ëŒ€ë¹„** | ë§ˆì´í¬ë¡œì½”ë“œ ëŒ€ì‹  ìƒíƒœ ë¨¸ì‹ ìœ¼ë¡œ ì§ì ‘ ì œì–´ êµ¬í˜„ |

### ğŸ§© Moore vs Mealy FSM

| í•­ëª©        | Moore FSM             | Mealy FSM                     |
| ----------- | --------------------- | ----------------------------- |
| ì¶œë ¥        | ìƒíƒœì—ë§Œ ì˜ì¡´         | ìƒíƒœ + ì…ë ¥ì— ì˜ì¡´            |
| ë°˜ì‘ ì†ë„   | 1í´ëŸ­ ëŠë¦¼            | ë°˜ì‘ ë¹ ë¦„                     |
| íšŒë¡œ ë³µì¡ë„ | ê°„ë‹¨í•¨                | ë³µì¡í•¨                        |
| ì œì–´ê¸° í™œìš© | CPU ì œì–´ê¸°, ìˆœì°¨ ë¡œì§ | UART ë“± ì‹¤ì‹œê°„ ë°˜ì‘ ìš”êµ¬ ì¥ì¹˜ |

âœ… CPU ì œì–´ê¸°ì—ì„œëŠ” ì¼ë°˜ì ìœ¼ë¡œ **Moore FSM** êµ¬ì¡°ê°€ ë„ë¦¬ ì‚¬ìš©ë¨.

### ğŸ“¦ FSM ê¸°ë°˜ CPU ì œì–´ê¸° ì˜ˆì‹œ

#### ğŸ¯ ëª©í‘œ: ëª…ë ¹ì–´ ì‹¤í–‰ íë¦„ì„ ìƒíƒœë¡œ ë‚˜ëˆ„ì

ì˜ˆ: `ADD R1, R2` ëª…ë ¹ì–´

| ìƒíƒœ | ë™ì‘                                       |
| ---- | ------------------------------------------ |
| S0   | ëª…ë ¹ì–´ fetch (PC â†’ MAR, read from memory)  |
| S1   | ëª…ë ¹ì–´ decode (IR â† M[PC])                 |
| S2   | í”¼ì—°ì‚°ì ì½ê¸° (ë ˆì§€ìŠ¤í„° R1, R2 â†’ ALU ì…ë ¥) |
| S3   | ì—°ì‚° ìˆ˜í–‰ (ALU: R1 + R2)                   |
| S4   | ê²°ê³¼ ì €ì¥ (ê²°ê³¼ â†’ R1), PC+1                |
| S5   | ë‹¤ìŒ ëª…ë ¹ì–´ ì¤€ë¹„ (ìƒíƒœ ì´ˆê¸°í™”)             |

### ğŸ“ˆ ìƒíƒœ ì „ì´ ë‹¤ì´ì–´ê·¸ë¨ (ê°„ë‹¨ FSM)

```
[S0] -- fetch --> [S1] -- decode --> [S2] -- read operands -->
[S3] -- execute --> [S4] -- writeback --> [S5] --â†’ [S0]
```

### ğŸ”§ FSM ì œì–´ê¸° Verilog êµ¬í˜„ ì˜ˆì‹œ (Moore íƒ€ì…)

```
module control_unit (
    input clk, reset,
    input [7:0] opcode,
    output reg [2:0] alu_op,
    output reg pc_write, ir_write, reg_write,
    output reg [2:0] state
);

    // ìƒíƒœ ì •ì˜
    localparam S0 = 3'd0,
               S1 = 3'd1,
               S2 = 3'd2,
               S3 = 3'd3,
               S4 = 3'd4;

    // ìƒíƒœ ë³€ìˆ˜
    reg [2:0] next_state;

    // ìƒíƒœ ì „ì´
    always @(posedge clk or posedge reset) begin
        if (reset) state <= S0;
        else state <= next_state;
    end

    // ë‹¤ìŒ ìƒíƒœ ê²°ì •
    always @(*) begin
        case (state)
            S0: next_state = S1;
            S1: next_state = S2;
            S2: next_state = S3;
            S3: next_state = S4;
            S4: next_state = S0;
            default: next_state = S0;
        endcase
    end

    // ìƒíƒœë³„ ì œì–´ ì‹ í˜¸ ì¶œë ¥
    always @(*) begin
        // ê¸°ë³¸ê°’
        pc_write = 0; ir_write = 0;
        reg_write = 0; alu_op = 3'b000;

        case (state)
            S0: begin // ëª…ë ¹ì–´ fetch
                pc_write = 1;
                ir_write = 1;
            end
            S2: begin // ALU ì…ë ¥ ì¤€ë¹„
                alu_op = 3'b000; // ADD
            end
            S4: begin // ê²°ê³¼ write-back
                reg_write = 1;
            end
        endcase
    end
endmodule
```

### ğŸ§  FSM ì œì–´ê¸°ì˜ ì¥ì 

| ì¥ì                   | ì„¤ëª…                                  |
| --------------------- | ------------------------------------- |
| **êµ¬í˜„ì´ ì§ê´€ì **     | ëª…ë ¹ì–´ íë¦„ = ìƒíƒœ íë¦„               |
| **ëª¨ë“ˆí™” ìš©ì´**       | ëª…ë ¹ì–´ ìœ í˜•ë§ˆë‹¤ ìƒíƒœ ë¶„ê¸° ê°€ëŠ¥        |
| **ë””ë²„ê¹…ì´ ì‰¬ì›€**     | ì–´ëŠ ìƒíƒœì—ì„œ ë©ˆì·„ëŠ”ì§€ ì‰½ê²Œ í™•ì¸ ê°€ëŠ¥ |
| **ì†Œê·œëª¨ CPUì— ì í•©** | ë§ˆì´í¬ë¡œì½”ë“œ ì—†ì´ë„ ì œì–´ ê°€ëŠ¥         |

### ğŸ§ª ì‹¤ì „: FSM ê¸°ë°˜ 8ë¹„íŠ¸ CPU ì„¤ê³„ íë¦„

1. **ëª…ë ¹ì–´ ì§‘í•© ì •ì˜**
   - ex) `LD, ADD, SUB, JMP, BZ`
2. **ëª…ë ¹ì–´ë³„ ë™ì‘ ë¶„í•´**
   - ê° ëª…ë ¹ì–´ë¥¼ ëª‡ ë‹¨ê³„ë¡œ ë‚˜ëˆŒ ê²ƒì¸ì§€ ê²°ì •
3. **ìƒíƒœ ì •ì˜ ë° ë‹¤ì´ì–´ê·¸ë¨ êµ¬ì„±**
4. **ì œì–´ ì‹ í˜¸ ê²°ì •**
   - ê° ìƒíƒœì—ì„œ ì–´ë–¤ ì œì–´ì„ ì´ ì¼œì§€ëŠ”ì§€
5. **Verilog/VHDL ì½”ë“œ ì‘ì„±**
6. **ì‹œë®¬ë ˆì´ì…˜ ë° íƒ€ì´ë° ê²€ì¦**

### ğŸ“Œ ìš”ì•½ ì •ë¦¬

| í•­ëª©                | ì„¤ëª…                                    |
| ------------------- | --------------------------------------- |
| **FSM ì œì–´ê¸°**      | ìƒíƒœ ê¸°ë°˜ìœ¼ë¡œ ëª…ë ¹ì–´ ì‹¤í–‰ íë¦„ì„ êµ¬ì„±   |
| **Moore FSM**       | ìƒíƒœì—ë§Œ ì˜ì¡´í•œ ì¶œë ¥ (CPUì— ì í•©)       |
| **ìƒíƒœ ë‹¤ì´ì–´ê·¸ë¨** | ëª…ë ¹ì–´ ì²˜ë¦¬ ë‹¨ê³„ë¥¼ ì‹œê°í™”               |
| **Verilog êµ¬í˜„**    | ìƒíƒœ ë³€ìˆ˜, ì „ì´ ë¡œì§, ì¶œë ¥ ë¡œì§ ë¶„ë¦¬    |
| **í™œìš© ë²”ìœ„**       | ë‹¨ìˆœ/ì¤‘í˜• CPU, ì»¨íŠ¸ë¡¤ëŸ¬, ì‹œë¦¬ì–¼ ì¥ì¹˜ ë“± |

## 10.4 íƒ€ì´ë° ë¶„ì„ ë° í´ëŸ­ ìŠ¤ì¼€ì¤„ë§

> CPU ë™ì‘ì˜ ì•ˆì „ì„±ê³¼ ì†ë„ë¥¼ ê²°ì •í•˜ëŠ” "ì‹œê°„"ì˜ ë¬¸ì œ

### ğŸ§  íƒ€ì´ë° ë¶„ì„ì´ë€?

**íƒ€ì´ë° ë¶„ì„(Timing Analysis)**ì€
 ë””ì§€í„¸ íšŒë¡œê°€ **í´ëŸ­ ì‚¬ì´í´ ë‚´ì— ì˜¬ë°”ë¥´ê²Œ ë™ì‘í•˜ëŠ”ì§€ë¥¼ ê²€ì¦**í•˜ëŠ” ê³¼ì •ì´ì•¼.

> ê° ì¡°í•©ë…¼ë¦¬ ê²½ë¡œì—ì„œ ì‹ í˜¸ê°€ ë„ë‹¬í•˜ëŠ” **ìµœëŒ€ ì§€ì—° ì‹œê°„**ì„ ê³„ì‚°í•´ì„œ
>  ì‹œìŠ¤í…œì´ ì•ˆì •ì ìœ¼ë¡œ ì‘ë™í•˜ëŠ” **ìµœì†Œ í´ëŸ­ ì£¼ê¸°(clock period)**ë¥¼ ê²°ì •í•¨.

### ğŸ“¦ ê¸°ë³¸ íƒ€ì´ë° ìš”ì†Œ

| í•­ëª©                              | ì„¤ëª…                                                |
| --------------------------------- | --------------------------------------------------- |
| **í´ëŸ­ ì£¼ê¸° (Tclock)**            | í•œ í´ëŸ­ ì‚¬ì´í´ì˜ ì‹œê°„                               |
| **í”„ë¡œíŒŒê²Œì´ì…˜ ì§€ì—° (tpd)**       | ê²Œì´íŠ¸/íšŒë¡œë¥¼ í†µê³¼í•˜ëŠ” ë° ê±¸ë¦¬ëŠ” ì‹œê°„               |
| **ì…‹ì—… íƒ€ì„ (Tsetup)**            | Dí”Œë¦½í”Œë¡­ì´ ë°ì´í„° ìƒ˜í”Œë§ ì „ì— ì•ˆì •ë˜ì–´ì•¼ í•˜ëŠ” ì‹œê°„ |
| **í™€ë“œ íƒ€ì„ (Thold)**             | í´ëŸ­ ì´í›„ì—ë„ ë°ì´í„°ë¥¼ ìœ ì§€í•´ì•¼ í•˜ëŠ” ìµœì†Œ ì‹œê°„      |
| **í´ëŸ­ ìŠ¤í (Clock Skew)**        | ë™ì¼ í´ëŸ­ì´ ë„ì°©í•˜ëŠ” ì‹œì ì˜ ì°¨ì´                    |
| **í¬ë¦¬í‹°ì»¬ íŒ¨ìŠ¤ (Critical Path)** | íšŒë¡œ ë‚´ ê°€ì¥ ê¸´ ì§€ì—° ì‹œê°„ ê²½ë¡œ                      |

### ğŸ” ë™ê¸°ì‹ íšŒë¡œ íƒ€ì´ë° ëª¨ë¸

```
       FF1         ì¡°í•© ë…¼ë¦¬            FF2
  D â”€â”€â”€â–¶â”‚       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚â—€â”€â”€ D
         â”‚       â”‚            â”‚        â”‚
  CLK â”€â–¶â”‚â”€â”€â”€â”€â”€â”€â–¶â”‚   Logic    â”‚â”€â”€â”€â”€â”€â”€â–¶â”‚â”€â”€â”€â–¶ CLK
         â”‚       â”‚            â”‚        â”‚
       Q â””â”€â”€â”€â”€â”€â–¶â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€ Q
```

#### ì¡°ê±´:

ë°ì´í„°ê°€ FF1ì—ì„œ Që¡œ ë‚˜ê°€ì„œ Logicì„ í†µê³¼í•˜ì—¬
 **FF2ì˜ ì…‹ì—… íƒ€ì„ ì „ê¹Œì§€ ë„ë‹¬í•´ì•¼ í•¨**

### ğŸ“ ìµœì†Œ í´ëŸ­ ì£¼ê¸° ê³„ì‚° ê³µì‹

```
Tclock â‰¥ Tsetup + Tlogic_max + Tskew
```

| ìš©ì–´           | ì„¤ëª…                           |
| -------------- | ------------------------------ |
| **Tsetup**     | í”Œë¦½í”Œë¡­ì˜ ì…‹ì—… íƒ€ì„           |
| **Tlogic_max** | ì¡°í•© ë…¼ë¦¬ì—ì„œì˜ ìµœì¥ ì§€ì—° ê²½ë¡œ |
| **Tskew**      | í´ëŸ­ ë„ë‹¬ ì‹œì  ì°¨ì´            |

> ì´ ê°’ì„ ì¤„ì´ë©´ ê³ ì† ë™ì‘ ê°€ëŠ¥ â†’ **íŒŒì´í”„ë¼ì¸, ìµœì í™”, ë¦¬íƒ€ì´ë°, ë©€í‹°ì‚¬ì´í´ ê²½ë¡œ ì²˜ë¦¬ ë“±**ì´ í•„ìš”í•¨

### ğŸ“‰ í¬ë¦¬í‹°ì»¬ íŒ¨ìŠ¤ ì°¾ê¸°

**í¬ë¦¬í‹°ì»¬ íŒ¨ìŠ¤(Critical Path)**ëŠ”
 **íšŒë¡œ ë‚´ ê°€ì¥ ì˜¤ë˜ ê±¸ë¦¬ëŠ” ë°ì´í„° ê²½ë¡œ**ì´ë©°, ì „ì²´ ì‹œìŠ¤í…œì˜ **ìµœëŒ€ ì†ë„ë¥¼ ì œí•œ**í•¨.

> íƒ€ì´ë° ë¶„ì„ ë„êµ¬(ì˜ˆ: Vivado, Quartus STA Report)ë¥¼ í†µí•´ ìë™ ë¶„ì„ ê°€ëŠ¥

### ğŸ”‚ ë©€í‹°ì‚¬ì´í´ ê²½ë¡œ ì²˜ë¦¬

ì–´ë–¤ ì—°ì‚°ì€ 1í´ëŸ­ì— ëë‚˜ì§€ ì•Šê³ , 2~3í´ëŸ­ì´ ê±¸ë¦´ ìˆ˜ ìˆì–´.
 â†’ í•´ë‹¹ ê²½ë¡œëŠ” íƒ€ì´ë° ì œì•½ì—ì„œ **ëŠìŠ¨í•˜ê²Œ ì²˜ë¦¬ ê°€ëŠ¥**

```
set_multicycle_path -from ALU_STAGE -to REG_OUT -setup 2
```

> í´ëŸ­ë‹¹ 1ê°œì”©ë§Œ ë™ì‘í•œë‹¤ê³  ê°€ì •í•˜ë©´ ë¹„íš¨ìœ¨ â†’ ë©€í‹°ì‚¬ì´í´ ê²½ë¡œë¡œ ì„ ì–¸í•˜ì—¬ ì†ë„ í–¥ìƒ ê°€ëŠ¥

### ğŸ”§ í´ëŸ­ ìŠ¤í (Clock Skew) ë¬¸ì œ

| ìœ í˜•              | ì„¤ëª…                              |
| ----------------- | --------------------------------- |
| **Positive Skew** | í´ëŸ­ì´ ëª©ì ì§€ FFì— ë” ëŠ¦ê²Œ ë„ì°©í•¨ |
| **Negative Skew** | í´ëŸ­ì´ ëª©ì ì§€ FFì— ë” ë¹¨ë¦¬ ë„ì°©í•¨ |
| **ì‹¬ê°í•œ ê²½ìš°**   | íƒ€ì´ë° ìœ„ë°˜, ì…‹ì—…/í™€ë“œ ì¡°ê±´ ë¯¸ë‹¬  |

#### í•´ê²° ë°©ë²•:

- ê· í˜• ì¡íŒ í´ëŸ­ íŠ¸ë¦¬ (H-tree êµ¬ì¡°)
- Clock Buffer ì‚½ì…
- **Clock Domain Crossing (CDC)** ì‹œì—” ë™ê¸°í™” íšŒë¡œ ì‚½ì…

### ğŸ•› í´ëŸ­ ë„ë©”ì¸ê³¼ CDC (Clock Domain Crossing)

í˜„ëŒ€ CPUëŠ” **ì—¬ëŸ¬ í´ëŸ­ ë„ë©”ì¸**ì„ ê°–ê¸°ë„ í•´:

| ì˜ˆì‹œ        | ì„¤ëª…                  |
| ----------- | --------------------- |
| CPU Core    | ê³ ì† í´ëŸ­ (1GHz ì´ìƒ) |
| Memory      | ì¤‘ì† (~400MHz)        |
| Peripherals | ì €ì† (50MHz ë“±)       |

> ë‹¤ë¥¸ í´ëŸ­ ë„ë©”ì¸ ê°„ ì‹ í˜¸ ì „ë‹¬ì€ **ë™ê¸°í™” íšŒë¡œ(2-stage FF)**ë‚˜ **FIFO + í•¸ë“œì…°ì´í¬**ë¡œ ì²˜ë¦¬í•´ì•¼ í•¨

### ğŸ“ˆ í´ëŸ­ ìŠ¤ì¼€ì¤„ë§ì´ë€?

í´ëŸ­ ìŠ¤ì¼€ì¤„ë§ì€ ë‹¤ìŒì„ í¬í•¨í•´:

1. **í´ëŸ­ ë„ë©”ì¸ ê°„ íƒ€ì´ë° ê³„íš**
2. **ì—°ì‚° ë¸”ë¡ë³„ í´ëŸ­ ì •ë ¬**
3. **ìŠ¬ë¡œìš° íŒ¨ìŠ¤ì—ëŠ” ë©€í‹°ì‚¬ì´í´ ì§€ì •**
4. **ìŠ¤ì¼€ì¤„ì— ë”°ë¼ ìµœì  í´ëŸ­ ìƒì„±ê¸° êµ¬ì„± (PLL, MMCM ë“±)**

### ğŸ› ï¸ íƒ€ì´ë° ë¶„ì„ ë„êµ¬ ì˜ˆ

| ë„êµ¬                               | ì„¤ëª…                                                         |
| ---------------------------------- | ------------------------------------------------------------ |
| **Vivado STA (Xilinx)**            | Synthesis â†’ Timing Report                                    |
| **Quartus TimeQuest (Intel FPGA)** | ì •í™•í•œ íƒ€ì´ë° ê·¸ë˜í”„ ì œê³µ                                    |
| **Synopsys PrimeTime**             | ASICìš© ëŒ€í‘œ STA ë„êµ¬                                         |
| **STA Constraints File (SDC)**     | `create_clock`, `set_input_delay`, `set_output_delay` ë“±ìœ¼ë¡œ ì„¤ì • |

### ğŸ“Œ ìš”ì•½ ì •ë¦¬

| í•­ëª©                | ì„¤ëª…                                     |
| ------------------- | ---------------------------------------- |
| **íƒ€ì´ë° ë¶„ì„**     | ê²½ë¡œ ì§€ì—° ì‹œê°„ ê¸°ë°˜ìœ¼ë¡œ í´ëŸ­ ì•ˆì •ì„± ê²€ì¦ |
| **ì…‹ì—… ì¡°ê±´**       | ë°ì´í„°ê°€ í´ëŸ­ ì „ì— ë„ë‹¬í•´ì•¼ í•¨           |
| **í™€ë“œ ì¡°ê±´**       | ë°ì´í„°ê°€ í´ëŸ­ ì´í›„ì—ë„ ìœ ì§€ë˜ì–´ì•¼ í•¨     |
| **í¬ë¦¬í‹°ì»¬ íŒ¨ìŠ¤**   | ì‹œìŠ¤í…œ ì „ì²´ì˜ ì†ë„ ë³‘ëª© ìš”ì†Œ             |
| **ë©€í‹°ì‚¬ì´í´ ê²½ë¡œ** | ëŠë¦° ì—°ì‚°ì˜ íƒ€ì´ë° ì œì•½ ì™„í™”             |
| **í´ëŸ­ ìŠ¤í**       | í´ëŸ­ ë„ë‹¬ ì‹œì  ë¶ˆê· í˜• â†’ ìŠ¤í‚µ/ì˜¤ë¥˜ ê°€ëŠ¥ì„± |
| **CDC ì²˜ë¦¬**        | ë™ê¸°í™” íšŒë¡œ, FIFO ë“± í•„ìš”                |

## 10.5 ëª…ë ¹ì–´ ì‹œë®¬ë ˆì´í„° ì œì‘

> ì‹¤ì œ CPUì²˜ëŸ¼ ë™ì‘í•˜ëŠ” â€œì†Œí”„íŠ¸ì›¨ì–´ CPUâ€

### ğŸ§  ISSë€?

**ëª…ë ¹ì–´ ì‹œë®¬ë ˆì´í„°(Instruction Set Simulator)**ëŠ”
 ì‹¤ì œ í•˜ë“œì›¨ì–´ ì—†ì´ë„ **CPUì˜ ëª…ë ¹ì–´ ì§‘í•©(ISA)ì„ í•´ì„í•˜ê³  ì‹¤í–‰í•´ë³´ëŠ” ì†Œí”„íŠ¸ì›¨ì–´ ëª¨ë¸**ì´ì•¼.

> ê°œë°œ ëª©ì :

- CPU ì„¤ê³„ ì „ ì‹œë®¬ë ˆì´ì…˜
- ì»´íŒŒì¼ëŸ¬ ê²€ì¦
- ìš´ì˜ì²´ì œ ì´ì‹ ì‹¤í—˜
- ì†Œí”„íŠ¸ì›¨ì–´ ë””ë²„ê¹…

### ğŸ“¦ ì£¼ìš” êµ¬ì„± ìš”ì†Œ

| êµ¬ì„± ìš”ì†Œ               | ì—­í•                                |
| ----------------------- | ---------------------------------- |
| **ë ˆì§€ìŠ¤í„° íŒŒì¼**       | ë²”ìš© ë ˆì§€ìŠ¤í„°ì™€ íŠ¹ìˆ˜ ë ˆì§€ìŠ¤í„° ì €ì¥ |
| **ë©”ëª¨ë¦¬ ëª¨ë¸**         | ê°€ìƒ RAM/ROM ê³µê°„                  |
| **ëª…ë ¹ì–´ ë””ì½”ë”**       | ëª…ë ¹ì–´ì˜ Opcode ë¶„ì„               |
| **ì‹¤í–‰ê¸°(Executor)**    | ëª…ë ¹ì–´ ì˜ë¯¸ì— ë”°ë¼ ì‹¤ì œ íš¨ê³¼ ë°˜ì˜  |
| **PC(Program Counter)** | ë‹¤ìŒ ì‹¤í–‰ ëª…ë ¹ì–´ ì£¼ì†Œ ì¶”ì          |
| **í”Œë˜ê·¸ ë ˆì§€ìŠ¤í„°**     | Zero, Carry, Negative ë“± ìƒíƒœ ì¶”ì  |
| **I/O ëª¨ë¸ (ì„ íƒ)**     | ì…ì¶œë ¥ í¬íŠ¸ ì‹œë®¬ë ˆì´ì…˜             |

### ğŸ”„ ì‹¤í–‰ íë¦„

```
while (!halted) {
    instr = memory[PC];
    opcode, operands = decode(instr);
    execute(opcode, operands);
    PC = update_PC(opcode, operands);
}
```

### ğŸ”¢ ì˜ˆì‹œ ISA ì •ì˜ (8ë¹„íŠ¸ ê°„ë‹¨ ISA)

| ëª…ë ¹         | í¬ë§·                 | ì˜ë¯¸                    |
| ------------ | -------------------- | ----------------------- |
| `LD Rn, imm` | `0001 nnnn dddddddd` | Rn â† imm                |
| `ADD Rn, Rm` | `0010 nnnn mmmm0000` | Rn â† Rn + Rm            |
| `SUB Rn, Rm` | `0011 nnnn mmmm0000` | Rn â† Rn - Rm            |
| `JMP addr`   | `0100 aaaaaaaa`      | PC â† addr               |
| `BZ addr`    | `0101 aaaaaaaa`      | if Zero == 1, PC â† addr |

### ğŸ› ï¸ C ê¸°ë°˜ ì‹œë®¬ë ˆì´í„° êµ¬í˜„ ì˜ˆì‹œ

#### âœ… ë ˆì§€ìŠ¤í„°/ë©”ëª¨ë¦¬ ëª¨ë¸

```
#define REG_COUNT 8
#define MEM_SIZE  256

uint8_t reg[REG_COUNT];
uint8_t memory[MEM_SIZE];
uint8_t pc = 0;
uint8_t zero_flag = 0;
```

#### âœ… ë””ì½”ë”© ë° ì‹¤í–‰

```
void execute_instruction() {
    uint8_t instr = memory[pc++];

    uint8_t opcode = (instr & 0xF0) >> 4;
    uint8_t operand = instr & 0x0F;

    switch(opcode) {
        case 0x1: // LD Rx, imm
            reg[operand] = memory[pc++];
            break;

        case 0x2: // ADD Rx, Ry
            reg[operand] += reg[memory[pc++]];
            zero_flag = (reg[operand] == 0);
            break;

        case 0x3: // SUB Rx, Ry
            reg[operand] -= reg[memory[pc++]];
            zero_flag = (reg[operand] == 0);
            break;

        case 0x4: // JMP addr
            pc = memory[pc];
            break;

        case 0x5: // BZ addr
            if (zero_flag)
                pc = memory[pc];
            else
                pc++;
            break;
    }
}
```

#### âœ… ë©”ì¸ ë£¨í”„

```
void run() {
    while (1) {
        execute_instruction();
    }
}
```

### ğŸ§ª í…ŒìŠ¤íŠ¸ í”„ë¡œê·¸ë¨ ì˜ˆ

```
// memory[0] = LD R0, 0x05
// memory[2] = LD R1, 0x03
// memory[4] = ADD R0, R1
memory[0] = 0x10; memory[1] = 0x05;
memory[2] = 0x11; memory[3] = 0x03;
memory[4] = 0x21; memory[5] = 0x00; // ADD R1, R0
```

â†’ ì‹¤í–‰ ê²°ê³¼: `R1 = 8`

### ğŸ“ˆ ê¸°ëŠ¥ í™•ì¥ ì•„ì´ë””ì–´

| í™•ì¥ ìš”ì†Œ                 | ì„¤ëª…                      |
| ------------------------- | ------------------------- |
| **ìŠ¤íƒ êµ¬ì¡° êµ¬í˜„**        | PUSH/POP, SP ë ˆì§€ìŠ¤í„°     |
| **I/O í¬íŠ¸ ëª¨ë¸ë§**       | `IN`, `OUT` ëª…ë ¹          |
| **ë©”ëª¨ë¦¬ ë§µ I/O**         | ì£¼ì†Œì— ë”°ë¼ I/O ë™ì‘ ì—°ê²° |
| **ì¸í„°ëŸ½íŠ¸ ì²˜ë¦¬**         | ì¸í„°ëŸ½íŠ¸ ë²¡í„°, ISR ì§„ì…   |
| **íŒŒì´í”„ë¼ì¸ ì‹œë®¬ë ˆì´ì…˜** | ë‹¨ê³„ë³„ ë ˆì§€ìŠ¤í„° ìœ ì§€ êµ¬ì¡° |
| **GUI ë””ë²„ê±°**            | ë ˆì§€ìŠ¤í„°/ë©”ëª¨ë¦¬ ë·° ì œê³µ   |

### ğŸ› ï¸ ë””ë²„ê¹… ë° ê²€ì¦ ë°©ë²•

| ë„êµ¬              | í™œìš© ë°©ë²•                      |
| ----------------- | ------------------------------ |
| `printf`          | PC, ëª…ë ¹ì–´, ë ˆì§€ìŠ¤í„° ìƒíƒœ ì¶œë ¥ |
| Trace íŒŒì¼ ìƒì„±   | ì‹¤í–‰ ë¡œê·¸ ê¸°ë¡ ë° ë¹„êµ         |
| Unit Test ì‘ì„±    | ëª…ë ¹ì–´ ë‹¨ìœ„ ê²€ì¦               |
| Instruction Trace | ëª…ë ¹ì–´ë³„ ì‚¬ì´í´, í”Œë˜ê·¸ í™•ì¸ìš© |

### ğŸ“Œ ìš”ì•½ ì •ë¦¬

| í•­ëª©          | ì„¤ëª…                                        |
| ------------- | ------------------------------------------- |
| **ISS**       | ì†Œí”„íŠ¸ì›¨ì–´ë¡œ êµ¬í˜„í•œ ëª…ë ¹ì–´ í•´ì„ê¸°           |
| **ì£¼ìš” êµ¬ì„±** | PC, ë©”ëª¨ë¦¬, ë ˆì§€ìŠ¤í„°, ë””ì½”ë”, ì‹¤í–‰ê¸°        |
| **ê¸°ëŠ¥**      | ëª…ë ¹ì–´ í•´ì„, ì‹¤í–‰, ìƒíƒœ ìœ ì§€                |
| **ì‘ìš©**      | CPU í…ŒìŠ¤íŠ¸, íˆ´ì²´ì¸ ê°œë°œ, êµìœ¡ìš©             |
| **í™•ì¥**      | íŒŒì´í”„ë¼ì¸ ëª¨ë¸, ì¸í„°ëŸ½íŠ¸, ìºì‹œ ëª¨ë¸ë§ ê°€ëŠ¥ |